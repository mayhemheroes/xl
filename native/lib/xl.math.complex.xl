// *****************************************************************************
// xl.math.complex.xl                                                 XL project
// *****************************************************************************
//
// File description:
//
//     Implementation of complex numbers
//
//     The interface does not specify the many special cases and optimizations,
//     but they are described in this file
//
//
//
//
//
//
//
// *****************************************************************************
// This software is licensed under the GNU General Public License v3+
// (C) 2018-2020, Christophe de Dinechin <christophe@dinechin.org>
// *****************************************************************************
// This file is part of XL
//
// XL is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// XL is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with XL, in a file named COPYING.
// If not, see <https://www.gnu.org/licenses/>.
// *****************************************************************************

use XL.MATH.FUNCTIONS

module COMPLEX[real, angle] is
// ----------------------------------------------------------------------------
//    Complex numbers taking the given `real` and 'angle' types
// ----------------------------------------------------------------------------

    // Imaginary unit
    i                   is imaginary(real 1)

    // Types for the rest of this implementation
    with
        X :complex;      Y:complex;      Z:complex
        XC:cartesian;   YC:cartesian;   ZC:cartesian
        XP:polar;       YP:polar;       ZP:polar
        XR:real;        YR:real;        ZR:real
        XI:imaginary;   YI:imaginary;   ZI:imaginary

    // Optimizations for various multiplications by [i]
    [[i]] * Z           is Z * i
    ZR * [[i]]          is imaginary(ZR)
    ZI * [[i]]          is -ZI.Im
    ZC * [[i]]          is cartesian(-ZC.Im, ZC.Re)
    ZP:polar * [[i]]    is polar(ZP.Mod, ZP.Arg + angle.quarter)

    // Implicit conversions between representations
    ZR                  is cartesian(ZR, real 0)
    ZR                  is polar(ZR, angle 0)
    ZI                  is cartesian(real 0, ZI.Im)
    ZI                  is polar(ZI.Im, angle.half)
    ZP                  is cartesian(re ZP, im ZP)
    ZC                  is polar(mod ZC, arg ZC)

    // Basic arithmetic in cartesian form
    XC + YC             is cartesian(XC.Re+YC.Re, XC.Im+YC.Im)
    XC - YC             is cartesian(XC.Re-YC.Re, XC.Im-YC.Im)
    XC * YC             is cartesian(XC.Re*YC.Re - XC.Im*YC.Im,
                                     XC.Re*YC.Im + XC.Im*YC.Re)
    XC / YC when YC ≠ 0 is
        Numerator   is cartesian(XC.Re*YC.Re + XC.Im*YC.Im,
                                 XC.Im*YC.Re - XC.Re*YC.Im)
        Denominator is YC.Re^2 + YC.Im^2
        Numerator / Denominator
    XC / YC when YC = 0 is
        error "Divide polar $1 by zero", XC, YC
    -ZC                 is cartesian(-ZC.Re, -ZC.Im)
    ~ZC                 is cartesian( ZC.Re, -ZC.Im)

    // Basic arithmetic optimizations for polar form multiply and divide
    XP * YP                     is polar(XP.Mod * YP.Mod, YP.Arg + YP.Arg)
    XP / YP when YP.Mod ≠ 0     is polar(XP.Mod / YP.Mod, XP.Arg - YP.Arg)
    XP / YP when YP.Mod = 0     is divide_error XP, YP
    -ZP                         is polar(ZP.Mod, ZP.Arg + angle.half)
    ~ZP                         is polar(ZP.Mod, -ZP.Arg)

    // Prefix form for field access
    re ZC                       is ZC.Re
    re ZP                       is ZP.Mod * cos(ZP.Arg)
    im ZC                       is ZC.Im
    im ZP                       is ZP.Mod * sin(ZP.Arg)
    mod ZC                      is sqrt(ZC.Re^2 + ZC.Im^2)
    mod ZP                      is ZP.Mod
    arg ZC                      is arctan(ZC.Im, ZC.Re)
    arg ZP                      is ZP.Arg

    // Comparisons
    XC = YC                     is XC.Re = YC.Re and XC.Im = YC.Re
    XC = 0                      is XC.Re = real 0 and YC = real 0
    XC < YC                     is XC.Re < YC.Re or (XC.Re = YC.Re and
                                                     XC.Im < YC.Im)

    // Some elementaty functions on complex numbers
    sqrt ZP                     is polar(sqrt(ZP.Mod), ZP.Arg / 2)
    exp  ZC                     is polar(exp(ZC.Re), ZC.Im radians)
    ln   ZP                     is cartesian(ln(ZP.Arg), radians(ZP.Mod))

    sin  ZC                     is ((exp(i*ZC) - exp(-i*ZC)) / (2*i))
    cos  ZC                     is ((exp(i*ZC) + exp(-i*ZC)) / 2)
    tan  ZC                     is (sin ZC / cos ZC)
    arcsin ZP                   is (ln(i * ZP + sqrt(1-ZP^2)) / i)
    arccos ZP                   is (ln(ZP + i * sqrt(1-ZP^2)) / i)
    arctan ZP                   is (ln((i-ZP)/(i+ZP)) / (2*i))

    sinh ZC                     is ((exp(ZC) - exp(-ZC)) / 2)
    cosh ZC                     is ((exp(ZC) + exp(-ZC)) / 2)
    tanh ZC                     is { p is exp(ZC); m is exp(-ZC); (p-m)/(p+m) }
    arcsinh ZP                  is ln(ZP + sqrt(ZP^2 + 1))
    arccosh ZP                  is ln(ZP + sqrt(ZP^2 - 1))
    arctanh ZP                  is ln((ZP+1) / (ZP-1)) / 2

    // Basic I/O
    to write ZI                 is write format("i%1", ZI.Im)
    to write ZC                 is write format("(%1, %2)", ZC.Re, ZC.Im)
    to write ZP                 is write format("(%1 ∠%2)", ZP.Mod, ZP.Arg)
    to read Z:out imaginary     is read('i', Z.Im)
    to read Z:out cartesian     is read('(', Z.Re,  ',', Z.Im,  ')')
    to read Z:out polar         is read('(', Z.Mod, '∠', Z.Arg, ')')

    // Errors
    type divide_error           is NUMBER.numeric_error
    type logarithm_error        is NUMBER.numeric_error
